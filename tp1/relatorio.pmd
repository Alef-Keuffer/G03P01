<header class="banner">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1600 400">
      <defs>
      <clipPath id="clipPolygon">
      <polygon points="1600,0 0,0 0,387 320,316 687,364 795,337 1068,400 1386,325 1600,385"/>
      </clipPath>
      </defs>
      <rect
     id="rect"
     x="0"
     y="0"
     width="750"
     height="375"
     fill="#7d3a40" />
  <path
     id="logo"
     fill="white"
     d="m 285.04181,144.159 -70.97287,41.3185 c -12.88463,7.43912 -24.21513,-12.12725 -11.32701,-19.56813 l 70.9815,-41.30287 c 12.90038,-7.44775 24.19063,12.12075 11.31838,19.5525 z m -183.45212,-19.31288 71.76875,40.67138 c 12.904,7.45062 1.60162,27.03237 -11.26825,19.60237 L 90.331058,144.43275 c -12.89175,-7.44313 -1.621,-27.02313 11.258632,-19.58663 z m 74.99875,169.02875 -0.0125,-82.54725 c 0,-6.24962 5.07687,-11.30087 11.30975,-11.30087 6.2415,0 11.3,5.05987 11.3,11.30112 l -0.0125,82.54713 c 0,6.23262 -5.0415,11.30037 -11.2915,11.30025 -6.2415,0 -11.30125,-5.05963 -11.30125,-11.30038 z m -86.619882,-63.66762 34.460502,-19.5645 c 12.87713,-7.43538 24.18938,12.14125 11.2915,19.58937 l -34.469,19.54838 C 88.362058,257.22312 77.086438,237.64562 89.968558,230.20725 z m 183.225132,20.21812 -33.56088,-20.24212 c -12.88088,-7.43688 -1.55275,-27.004 11.34038,-19.56063 l 33.55225,20.25838 c 12.86862,7.43 1.57099,26.99425 -11.33175,19.54437 z m -73.96,-169.300622 0.0125,39.627122 c 0,6.24938 -5.07688,11.301 -11.30975,11.301 -6.2415,0 -11.30138,-5.05987 -11.30138,-11.301 l 0.0125,-39.627122 c 0,-6.2325 5.0415,-11.3 11.2915,-11.3 6.24138,0 11.3,5.05862 11.3,11.3 z" />
    </svg>
</header>

# BibTeXPro, Um processador de BibTeX

**Instituição:** Universidade do Minho

**Cadeira:** Processamento de Linguagens e Compiladores (2021/2022)

**Identificação:** plc21TP1gr03

**Equipa**
: [Alef Keuffer](https://github.com/Alef-Keuffer/) (A91383)
: [Ivo Lima](https://github.com/IvoLims) (A90214)
: [Catarina Quintas](https://github.com/CatarinaQuintas) (A91650)


## O formato $Bib\TeX$

$Bib\TeX$ é a ferramenta e formato de ficheiro usado para descrever e processar listas de referências, principalmente em conjunção com $La\TeX$.

### Entrada $Bib\TeX$

Uma entrada $Bib\TeX$ consiste em um **tipo de entrada**, uma **chave de citação** e um número de **campos** que definem várias caraterísticas de uma entrada específica.[^format].

Existem 17 tipos de entrada, sendo 14 categorias de referência e 3 de uso específico em $Bib\TeX$.

As entradas não são _case sensitive_^[https://tex.stackexchange.com/questions/163687/is-there-a-preferred-capitalization-style-for-reference-types-in-bibtex-biblatex].

A documentação diz que ficheiros $Bib\TeX$ podem conter 4 tipos de entrada: `@string`, `@preamble`, `@comment` e 14 categorias (e.g. `@article`, `@book`, etc)[^format].

[^format]: http://www.bibtex.org/Format/

Note que:

`@string`
  : define abreviações que podem se usadas depois em um campo.

`@preamble`
  : define como um texto especial deve ser formatado.

`@comment`
  : para comentários que não devem ser levados em conta pelo $Bib\TeX$.

Estas três não seram processadas pelo nosso programa.

## Especificação da Solução

A nossa solução deve satisfazer os seguintes requisitos<a name="req"></a>:

(R1)<a name="R1"></a>
: Fazer a contagem das categorias presentes no documento, tais como: _phDThesis_, _Misc_, _InProceeding_, etc.

(R2)<a name="R2"></a>
: Produzir um documento em formamto _HTML_ com <a name="R21"></a>(R2.1) o nome das categorias encontradas e <a name="R22"></a>(R2.2) respectivas contagens.

(R3)<a name="R3"></a>
: Filtrar, para cada entrada de cada categoria, a respetiva <a name="R31"></a>(R3.1) chave, <a name="R32"></a>(R3.2) autores e <a name="R33"></a>(R3.3) título. <a name="R34"></a>(R3.4) O resultado final deverá ser incluído no documento _HTML_ gerado em [(R2)](#R2).

(R4)<a name="R4"></a>
: Criar um índice de autores, que mapeie cada autor nos respectivos registos, de modo a que posteriormente uma ferramenta de procura do Linux possa fazer a pesquisa.

(R5)<a name="R5"></a>
: Construir um Grafo que mostre, para um dado autor (definido à partida) todos os autores que publicam normalmente com o autor em causa.

(R6)<a name="R6"></a>
: Recorrendo à linguagem _Dot_ do _GraphViz_, gerar um ficheiro com o grafo de [(R5)](#R5) de modo a que possa, posteriormente, usar uma das ferramentas que processam _Dot_ para desenhar o dito grafo de associações de autores.

## Execução do programa

Para realizar as modificações no ficheiro usamos `solve(author_name,INPUT_FILENAME=BIB_EXAMPLE_FILENAME)`, passando como argumento o nome do autor que queremos conforme [(R5)](#R5).

```python, echo = False
#!/usr/bin/python
```

## Módulo não é `re`

Usamos o módulo `regex` que é um _superset_ de `re` mais poderoso. Seu uso será justificado.

```python
import regex as re
```

## Algumas constantes

Aqui incluimos _MathJax_, uma biblioteca em _javascript_, para renderizar fórmulas matemáticas nos navegadores.

```python
MATHJAX = '''
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    "extensions":["tex2jax.js"],
                    "jax":["input/TeX",
                           "output/HTML-CSS"],
                    "messageStyle":"none",
                    "tex2jax":{
                        "processEnvironments":false,
                        "processEscapes":true,
                        "inlineMath":[["$","$"]],
                        "displayMath":[]
                    },
                    "TeX":{
                        "extensions":["AMSmath.js",
                                      "AMSsymbols.js",
                                      "noErrors.js",
                                      "noUndefined.js"]
                    },
                    "HTML-CSS":{
                        "availableFonts":["TeX"]
                    }
                });
            </script>

            <script type="text/javascript" async
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js">
            </script>
'''
```

O início do nosso _HTML_ é

```python
HTML_PROLOGUE = f'''<!DOCTYPE  html>
    <HTML lang="en">
        <HEAD>
            <meta charset="utf-8">
            <TITLE>Categories in BibTeX</TITLE>
            {MATHJAX}
        </HEAD>'''
```

Vamos ter que fechar a tag _HTML_ que começamos em `HTML_PROLOGUE`:

```python
HTML_EPILOGUE = '</HTML>'
```

O ficheiro dado como argumento de entrada é o ficheiro `exemplo-utf8.bib`.

```python
BIB_EXAMPLE_FILENAME = "exemplo-utf8.bib"
```

Decidimos nomear o output `output.html`.

```python
OUTPUT_FILENAME = 'output.html'
```

## Função principal


Em `solve()` temos a váriavel `html_str_ls` que consiste numa lista de _strings_ que serão concatenadas. A título de optimização da imutabilidade de _strings_ (concatenação de _strings_ em _python_ cria uma cópia de cada), optamos por fazer sucessivos _appends_ de custo $\cal{O}(1)$ e por fim, concatena-las para formar o código _HTML_.

Em `bib_str` guardamos todo o texto contido em `INPUT_FILENAME`.

```python, wrap=True
def solve(author_name,INPUT_FILENAME=BIB_EXAMPLE_FILENAME):
    html_str_ls = [HTML_PROLOGUE]
    bib_str = get_bib_str(INPUT_FILENAME)

    entries = get_entries(bib_str)
    format_authors(entries)
    fix_repeated_authors(entries)

    html_str_ls.append(
        html_enclose('body',
            get_html_pub_type_counts(entries)
            + get_html_common_pub_author(author_name,entries)
            + get_html_pub_type_index(entries)
            + get_html_author_index(entries)))

    html_str_ls.append(HTML_EPILOGUE)
    with open(OUTPUT_FILENAME,'w') as file:
        file.write('\n'.join(html_str_ls))
```

`get_bib_str()` é utilizada para abrir e extrair o conteúdo do ficheiro.

```python
def get_bib_str(filename):
    with open(filename,'r') as file:
        return file.read()
```

## Recolhendo as entradas

Neste procedimento, criamos um dicionário onde cada chave é um par (categoria de publicação, nome do autor) e o valor é um dicionário em que cada chave é um campo da entrada $Bib\TeX$ e o valor é o valor do campo.


```python, evaluate = False
def get_entries(string):
    d = {}
```

Poderíamos coletar todos os campos de todas as entradas, mas neste trabalho só são relevantes alguns campos. Então, para economizar espaço no dicionário, definimos:

```python, evaluate = False
    RELEVANT_FIELDS = {'author','title'}
```

Como foi dito anteriormente, alguns tipos de entrada não são categorias de referência, assim iremos ignorá-los.

```python, evaluate = False
    SPECIAL_TYPES = {'comment','string','preamble'}
```

É aqui que se justifica o uso do módulo `regex`. Note a expressão regular:

```python, evaluate = False
    between_cbrace_ex = r'(?:(?<rec>{(?<value>[^{}]+|(?P>rec))*+}))'
```

Nela usamos um padrão recursivo não suportado pelo módulo `re`. O padrão é usado para capturar o que está entre chavetas, que podem estar aninhadas arbitrariamente.


```python, evaluate = False
    field_match = re.compile(rf'(?<name>\w+)\s*=\s*({between_cbrace_ex}|"(?<value>[^"]+)"|(?<value>\d+))')
    entry_match = re.compile(rf'@(?<type>\w+)(?<value>{between_cbrace_ex})')
    key_match = re.compile(r'([^{},~#%\\]+),')

    for entry in entry_match.finditer(string):
        entry_type = entry['type'].lower()
        if entry_type not in SPECIAL_TYPES:
            key = key_match.search(entry['value'])[1]
            d[entry_type, key] = {
                field['name'].lower(): field['value']
                for field in field_match.finditer(entry['value'])
                if field['name'].lower() in RELEVANT_FIELDS
            }

    return d
```

## Procedimentos usados ao longo do programa

### Relacionados a expressões $La\TeX$

#### Chavetas

Assumimos que as chavetas estão balanceadas.

Chavetas dentro de títulos são usadas para prevenir que palavras sejam convertidas em letras minúsculas (se "sentence style" é usado ao invés de "title style")^[https://tex.stackexchange.com/questions/109064/is-there-a-difference-between-and-in-bibtex:].

Por exemplo, devemos usar chavetas para escrever

`title = "The Life of {Albert} {Einstein}"`

ou, de forma equivalente,

`title = {The life of {Albert} {Einstein}}`

se quisermos garantir que as letras 'A' e 'E' sejam sempre formatadas em letras maiúsculas mesmo que "sentence style" esteja sendo usado.

Suspeitamos que talvez pudessemos usar:

```py
r'[^\\]\$.*[^\\]\$'
```

para identificar que não estamos dando _escape_ no _dollar sign_. Mas já tinhamos esse procedimento feito e decidimos por não alterá-lo.

<a name="unbrace"></a>

```python
def unbrace(expression):
    string_ls = []
    is_between_dollar_sign = False
    is_previous_backslash = False
    for c in expression:
        if c == '$' and not is_previous_backslash:
            if is_between_dollar_sign:
                is_between_dollar_sign = False
            else:
                is_between_dollar_sign = True
        if c == '\\':
            is_previous_backslash = True
        else:
            is_previous_backslash = False
        if c in '{}' and not is_between_dollar_sign:
            continue
        string_ls.append(c)
    return ''.join(string_ls)
```

### Relacionados a _HTML_

É muito comum em _HTML_ o uso de _tags_ para marcar uma expressão. Então, criamos um procedimento que facilita cercar uma expressão pela _tag_ desejada.

```python
def html_enclose(tag,string):
    return rf'<{tag.upper()}>{string}</{tag.upper()}>'
```

Nesse sentido, _spans_ são muito úteis em _HTML_, logo criamos:

```python
def html_create_span(expression):
    return html_enclose('span',expression)
```

Às vezes queremos adicionar um atributo numa _tag_, nesse caso podemos usar (há um pequeno problema com esse procedimento, mas para nosso uso não foi relevante):

```python
def html_add_attr(attr,val,html_expression):
    return re.sub(r'<(\w+)([^>]*)\s*>(.*)</\1>',rf'<\1\2 {attr.upper()}="{val}">\3</\1>',html_expression)
```

### Relacionados a _Regex_

Em certas ocasiões, desejamos fazer várias substituições seguidas numa _string_, logo criamos:

```python
def mult_replace(string, replacement_list):
    for old, new in replacement_list:
        string = re.sub(old, new, string)
    return string
```

## Tratamento do nome dos autores

Escolhemos remover acentuações e caráteres especiais que as representam em $La\TeX$ (e.g. `\~`) do nome dos autores.

É importante notar que ainda ocorrem alguns problemas de acentuações uma vez que não removemos acentuações do tipo `\~{}`.

```python
def format_authors(data):
    for d in data.values():
        if "author" in d:
            author_lst = [ remove_consecutive_spaces(
                           str.strip(
                           invert_name(
                           unbrace(
                           remove_accents(name)))))
                           for name in re.split(r"\band\b", d["author"].replace("\n", " "))]
            d['author'] = [author for author in author_lst if author]
```

### Procedimentos auxiliares

```python
def remove_consecutive_spaces(name):
    return re.sub(r'\s+',' ',name)
```

#### Inversão das componentes do nome

Para inverter nomes do tipo: last_name, first_name. Por exemplo: "da Cruz, Daniela" → "Daniela da Cruz"

```python
def invert_name(author_name):
    return re.sub(r"([^,]+),\s*([^,]+)", r"\2 \1", author_name)
```

#### Remoção de acentuações

```python
def remove_accents(name):
    return remove_latex_accent(remove_normal_accent(name))
```

Para remoção de acentos $La\TeX$ consultamos a [wiki](https://en.wikibooks.org/wiki/LaTeX/Special_Characters).

Pensamos em possivelmente usar algo como:

```py
re.sub(r'\\{?(acento)}?',rf'{fix_accent(\1)}',author_name)
```

para manter acentuações, mas devido a restrições de tempo não achamos prudente embarcar nesta ideia.

```python
def remove_latex_accent(name):
    return re.sub(r'\\\W','',name)
```

Aqui removemos palavras com acentuações normais, isto é, palavras como "á", "é", "í", etc (não $La\TeX$).

```python
def remove_normal_accent(name):
    import unicodedata
    return ''.join((c for c in unicodedata.normalize('NFD', name) if unicodedata.category(c) != 'Mn'))
```

Também usamos a já referenciada [`unbrace()`](#unbrace).

## Tratando autores repetidos na estrutura

No dicionário, teremos autores repetidos (pois podem estar escritos de formas diferentes, omitindo alguns sobrenomes ou até mesmo primeiros nomes).

Por exemplo, 'M. J. Varanda', 'M. Joao Varanda', 'Maria Joao Varanda' e 'Maria Joao V. Pereira' são diferentes maneiras de se referir a mesma pessoa.

```python
def fix_repeated_authors(data):
    author_blocks = fix_block_func(
                        block_authors_with_two_common_names_v2(
                            get_author_list(data)))

    author_dict = {author_name:max(s,key=len)
                   for s in author_blocks
                   for author_name in s}

    for d in data.values():
        d['author'] = [author_dict[author]
                       for author in d['author']]
```

Para lidar com isso, realizamos três procedimentos:

1. Obtemos uma lista dos autores ordenada alfabeticamente.
2. Criamos conjuntos onde os seus elementos representam um mesmo autor. Ou seja, se temos três nomes: $A$, $B$ e $C$ e temos os conjuntos $\{A,B\}$ e $\{B,C\}$, então os nomes $A,B,C$ referem-se ao mesmo autor.
3. Juntamos esses blocos para que cada bloco seja um único autor. Ou seja, determinamos uma "transitividade" nos blocos, usando o exemplo anterior, se temos $\{A,B\}$ e $\{B,C\}$, devemos obter $\{A,B,C\}$.

### Procedimento 1

```python
def get_author_list(data):
    return sorted(set([a for s in data.values() for a in s.get("author", [])]))
```

### Procedimento 2

```python, evaluate = False
def block_authors_with_two_common_names_v2(authors):
    res = set()
    for author in authors:
        fs = set()
        for author2 in authors:
            a1 = set(re.findall(r'\w\w+',author))
            a2 = set(re.findall(r'\w\w+',author2))
```

Se os autores tem mais de duas componentes do nome em comum, então podemos considera-los o mesmo autor.

```python, evaluate = False
            if len(a1.intersection(a2)) > 1:
                fs.add(author2)
```

Para lidar com a situação descrita abaixo, assumimos que a primeira componente de um nome nunca será omitida.

Caso especial: Suponha que existe um autor que só tem uma componente do nome não abreviada (e.g. P. Henriques). Suponha que outro autor (e.g. P.R. Henriques) também só tem uma componente do nome não abreviada e essa componente é igual a do primeiro autor. Então ainda temos que fortalecer a condição para que sejam considerados iguais. Para isso, usamos `is_a_first_last_match()` garantindo que pelo menos a abreviação da primeira componente dos nomes sejam iguais.

```python, evaluate = False
            elif len(a1) == 1 and len(a1.intersection(a2)) == 1 and is_a_first_last_match(author,author2):
                fs.add(author2)
        res.add(frozenset(fs))
    return res
```

Pra implementar `is_a_first_last_match()` usamos `get_crude_abbrev()` para obter uma string com o primeiro caráter de cada componente do nome de um autor (e.g. "Ricardo Henriques → RH").

```python
def get_crude_abbrev(name):
    return ''.join(c for c in name if c.isupper())
```

Aqui iremos verificar se os primeiros caráteres da primeira e última componente do nome de um autor $a_1$ são iguais, respetivamente, aos primeiros e últimos caráteres da primeira e última componente do nome de um autor $a_2$.

```python
def is_a_first_last_match(author1,author2):
    a1 = get_crude_abbrev(author1)
    a2 = get_crude_abbrev(author2)
    return a1[0] == a2[0] and a1[-1] == a2[-1]
```

### Procedimento 3

Objetivo: Criar a "transitividade" nos blocos dos autores referenciada no ínicio.

```python
def fix_block_func(data):
    res = set()
    for q in data:
        for s2 in data:
            if q.intersection(s2) != set():
                q = q.union(s2)
        res.add(frozenset(q))
    return res
```

## Contagem dos tipos de publicações

Conforme [(R1)](#R1), devemos contar quantas publicações de cada tipo existem.

```python
def get_pub_type_counts(data):
    pub_types_occur = [x[0] for x in data.keys()]
    pub_types = set(pub_types_occur)
    return [(pub_type, pub_types_occur.count(pub_type)) for pub_type in pub_types]
```

Conforme [(R2)](#R2) queremos incorporar a contagem de publicações de cada tipo no documento _HTML_ que iremos produzir.

```python
def get_html_pub_type_counts(data):
    string_ls = [html_enclose('h2',
                              'Number of Occurrences of Publication Types')]
    pub_counts = sorted(
        get_pub_type_counts(data),
        key=lambda x: x[1],reverse=True)

    time = lambda v: 's' if v > 1 else ''
    for pub_type, count in pub_counts:
        string_ls.append(
            html_enclose('p',
                         f'Type {pub_type} appears {count} time{time(count)}'
            )
        )

    return ''.join(string_ls)
```

### Solução inicial

A estratégia para satisfazer [(R1)](#R1) consistiu em ler o arquivo linha a linha verificando se a categoria encontrada já aparecia no dicionário, se já existir, irá ser incrementado o número de ocorrências, senão será adicionado como primeira ocorrência, para que depois possa ser produzido um ficheiro _HTML_ com todas as categorias e o devido número de ocorrências.

De seguida apresentamos a Expressão Regular utilizada para filtrar a informação pedida em [(R1)](#R1).

Uma vez que todas as categorias num $Bib\TeX$ têm como antecedente o caráter `@` e terminam numa `{`, tornou-se fácil criar um filtro que guarde toda a informação delimitada entre esses dois parâmetros.

Através dessa pequena realização chegamos à seguinte expressão: `r'^@(.*){'`

```py
import re

file = open("exemplo-utf8.bib", "r")
read = True
dic = {}
string_ls = ['<!DOCTYPE  HTML PUBLIC>\n<HTML>\n   <HEAD>\n      '\
             '<TITLE>Categories in BibTeX</TITLE>\n   </HEAD>\n   <BODY>']
while read:
    linhaFicheiro = file.readline()
    ncat = re.match(r'^@(.*){',linhaFicheiro)
    if ncat != None:
       cat_title = ncat.group(1).title()
       dic[cat_title] = dic.get(cat_title,0) + 1
    if not linhaFicheiro:
       read = False
       file.close()

time = lambda v: 's' if v > 1 else ''

for k, v in dic.items():
    string_ls.append(f'      <P>The category {k} appears {v} time{time(v)}.</P>')
    string_ls.append(f'   </BODY>\n</HTML>')
with open('output.html','w') as file:
     file.write('\n'.join(string_ls))
```

Infelizmente a estratégia adotada na primeira questão de unicamente guardar aquilo que interessava tornou-se impraticável pois não era escalável para a extração e manipulação necessária dos restantes parâmetros pedidos nas outras questões.

## Criação do grafo

Conforme [(R5)](#R5) queremos construir um grafo que represente a co-autoria entre os autores.

```python
def get_author_pub_graph(author,data):
    pub_partners = []
    for entry in data.values():
        if 'author' in entry and author in entry['author']:
            for partner in entry['author']:
                if partner != author:
                    pub_partners.append(partner)
    return [(author_name,pub_partners.count(author_name))
            for author_name in set(pub_partners)]
```

Conforme [(R6)](#R6) iremos recorrer a linguagem _Dot_ para renderizar o grafo.

```python
def get_dot_graph(author,data):
    import textwrap
    g = sorted(get_author_pub_graph(author,data),key = lambda x: x[1])
    string_ls = ['graph{']
    string_ls2 = []
    for partner_author,no_joint_pub in g[-3:]:
        string_ls2.append(f'"{author}" -- "{partner_author}" [label="{no_joint_pub}"]')
    string_ls.append(textwrap.indent('\n'.join(string_ls2),'  '))
    string_ls.append('}')
    return '\n'.join(string_ls)
```

Como ideia nossa para ir além do que foi pedido, decidimos incorporar o grafo no documento _HTML_ que iremos produzir.

Utilizamos `re.search()` porque o arquivo gerado contém um preâmbulo _XML_ como _doctype_. Só queremos o _SVG_.

```python
def get_html_dot_svg(author,data):
    import os
    DOT_INPUT_FILENAME = 'dot_input'
    with open(DOT_INPUT_FILENAME,'w') as file:
        file.write(get_dot_graph(author,data))
    os.system(f'dot -T svg -O {DOT_INPUT_FILENAME}')
    with open(DOT_INPUT_FILENAME + '.svg','r') as file:
        return re.search(r'<svg(?:.|\n)+</svg>',file.read()).group()
```

Finalmente,

```python
def get_html_common_pub_author(author,data):
    string_ls = [html_enclose('h2','Author Graph')]
    string_ls.append(get_html_dot_svg(author,data))
    return ''.join(string_ls)
```

que é responsável por gerar:

![](auth_graph.png)

na página _HTML_.

## Filtrar (chave,autore,título)

### Títulos

Pelo [(R3.3)](#R33), devemos incluir títulos. Para isso devemos aplicar um tratamento para uma formatação mais elegante (como manter expressões $La\TeX$).

Note que formatamos _small caps_ como pode ser notado em entradas que contém "Camila". Também formatamos _sans serif_ e algumas expressões matemáticas.

```python
def fix_title(title):
    substitutions = [(r'\\textsc{((?:\\{|[^{])+)}',
                      lambda m: f'{html_to_small_caps(html_create_span(m.group(1)))}'),
                     (r'\\textsf{((?:\\{|[^{])+)}',
                      lambda m: f'{html_to_sans_serif(html_create_span(m.group(1)))}'),
                     (r'(\$(?:.|\\\$)+\$)',
                      lambda m: f'{str_to_html_math(m.group(1))}')]


    replace = lambda x: mult_replace(x,substitutions)

    return   html_create_span(
             single_quote_latex(
             double_quote_latex(
             unbrace(
             replace(
             remove_latex_special_chars(
             ' '.join(s.strip() for s in title.split('\n'))))))))
```

#### Tratamento de caráteres $La\TeX$

```python
def double_quote_latex(expression):
    return re.sub(r"``(.*[^\\])''",r'"\1"',expression)
```

```python
def single_quote_latex (expression):
    return re.sub(r"[^`]`([^`].*[^'])'[^`]",r"'\1'",expression)
```

```python
def remove_latex_special_chars(latex_expression):
    return re.sub(r'\\({|[^{])\b',r'\1',latex_expression)
```

### Formatações especiais

#### Small caps

Usado para converter expressoes latex `\textsc{expression}`

```python
def html_to_small_caps(html_expression):
    return html_add_attr('style','font-variant:small-caps',html_expression)
```

Para incluir no _HTML_:

```python
def str_to_html_small_caps(expression):
    return html_to_small_caps(html_create_span(expression))

```

#### Sans serif

```python
def html_to_sans_serif(html_expression):
    return html_add_attr('style','font-family:sans-serif',html_expression)
```

#### Matemática

```python
def str_to_html_math(string):
    return html_add_attr('class','math inline',html_create_span(string))
```

### Incorporar no documento _HTML_

Como fica renderizado:

![](auth_ind.png)

Conforme [(R3.4)](#R34):

```python
def get_html_pub_type_index(data):
    string_ls = [html_enclose('h2','Publication Type Index')]
    for entry_type in sorted(set(x[0] for x in data)):
        string_ls.append(html_enclose('h3',entry_type))
        for citation_key in [x[1] for x in data if x[0]==entry_type]:
            title = data[entry_type,citation_key].get('title','')
            authors = ', '.join((sorted(data[entry_type,citation_key].get('author',''))))
            string_ls.append(
                html_enclose('p',
                             f"Key = {citation_key}<br>Title = {fix_title(title)}<br>Autores = {authors}"))

    return '\n'.join(string_ls)
```

## Índice de autores

Conforme [(R4)](#R4) iremos criar um índice de autores.

Geralmente, nos índices de autores, o apelido aparece primeiro seguido pelas iniciais dos outros nomes. Com esse propósito, criamos o procedimento que recebe um nome normalizado (e.g. Pedro Filipe H. Pereira), retornando-o "invertido" e abreviado (e.g. Pereira, P. F. H.).

```python
def last_name_first(name):
    initials =  '. '.join(get_crude_abbrev(name))[:-2]
    last_name = name.split()[-1]
    return f'{last_name}, {initials}'
```

Utilizamos `last_name_first()` na construção de um dicionário que irá conter como chaves o nome do autor já formatado e como valor todas as chaves de citações de suas publicações.

```python
def get_author_index_dict(data):
    index = {}
    for key, e in data.items():
        if 'author' in e:
            for author in e['author']:
                author_name = last_name_first(author)
                if author_name not in index:
                    index[author_name] = set()
                index[author_name].add(key[1])
    return index
```

Decidimos incorporar o índice no documento _HTML_ que iremos produzir.

```python
def get_html_author_index(data):
    index = sorted(get_author_index_dict(data).items())
    alphabet_order = sorted(set(c[0][0] for c in index))
    string_ls = [html_enclose('h2','Author Index')]
    i = 0
    string_ls.append(html_enclose('h3',alphabet_order[i]))
    for author,citation_keys in index:
        if author[0] != alphabet_order[i]:
            i += 1
            string_ls.append(html_enclose('h3',alphabet_order[i]))
        citation_keys_str = ', '.join(citation_keys)
        string_ls.append(html_enclose('p',f'{author}, {citation_keys_str}'))
    return '\n'.join(string_ls)
```

## Execução pela linha de comandos

Este bloco é utilizado para executar o programa pela linha de comandos.

```python, evaluate = False
if __name__ == '__main__':
    import sys
    import os.path
```

Para facilitar a realização de testes deixamos o valor _standard_ do `filename` para o ficheiro exemplo.

```python, evaluate = False
    filename = sys.argv[1] if len(sys.argv) > 1 else BIB_EXAMPLE_FILENAME
    assert os.path.isfile(filename)
```

Novamente, para facilitar a realização de testes (executar sem passar o argumento com o nome do autor) escolhemos a autora Daniela da Cruz que está presente no ficheiro `exemplo-utf8.bib` com o intuito de gerar o grafo conforme [(R5)](#R5).


```python, evaluate = False
    if len(sys.argv) < 3:
        author_name = 'Daniela da Cruz'
    else:
        author_name = sys.argv[2]
    solve(author_name,filename)

```

## Conclusão

Através deste projeto foi possível expandir as nossas competências intelectuais sobre o tópico de estudo: Expressões Regulares (ER) que nos possibilitou desenvolver um processador $Bib\TeX$ utilizando a linguagem _Pyhton_ para extrair informações relavantes. Além disso, aumentamos a nossa familiaridade com _HTML_ pois dispusemos as informações coletadas numa página _web_, onde inserimos um grafo gerado usando a linguagem _Dot_.

Consideramos que o produto final cumpre os [requisitos](#req).

Este projeto foi desafiante (pela complexidade do $La\TeX$) e enriquecedor (pela variedade de linguagens usadas) para cada um de nós, uma vez que tivemos a oportunidade de expandir, aprofundar e aperfeiçoar os nossos conhecimentos.

## Apêndices

### _Source Code_

```py
#!/usr/bin/python

import regex as re

MATHJAX = '''
            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    "extensions":["tex2jax.js"],
                    "jax":["input/TeX",
                           "output/HTML-CSS"],
                    "messageStyle":"none",
                    "tex2jax":{
                        "processEnvironments":false,
                        "processEscapes":true,
                        "inlineMath":[["$","$"]],
                        "displayMath":[]
                    },
                    "TeX":{
                        "extensions":["AMSmath.js",
                                      "AMSsymbols.js",
                                      "noErrors.js",
                                      "noUndefined.js"]
                    },
                    "HTML-CSS":{
                        "availableFonts":["TeX"]
                    }
                });
            </script>

            <script type="text/javascript" async
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js">
            </script>
'''

HTML_PROLOGUE = f'''<!DOCTYPE  html>
    <HTML lang="en">
        <HEAD>
            <meta charset="utf-8">
            <TITLE>Categories in BibTeX</TITLE>
            {MATHJAX}
        </HEAD>'''

HTML_EPILOGUE = '</HTML>'

BIB_EXAMPLE_FILENAME = "exemplo-utf8.bib"

OUTPUT_FILENAME = 'output.html'

def solve(author_name,INPUT_FILENAME=BIB_EXAMPLE_FILENAME):
    html_str_ls = [HTML_PROLOGUE]
    bib_str = get_bib_str(INPUT_FILENAME)

    entries = get_entries(bib_str)
    format_authors(entries)
    fix_repeated_authors(entries)

    html_str_ls.append(
        html_enclose('body',
            get_html_pub_type_counts(entries)
            + get_html_common_pub_author(author_name,entries)
            + get_html_pub_type_index(entries)
            + get_html_author_index(entries)))

    html_str_ls.append(HTML_EPILOGUE)
    with open(OUTPUT_FILENAME,'w') as file:
        file.write('\n'.join(html_str_ls))

def get_bib_str(filename):
    with open(filename,'r') as file:
        return file.read()

def get_entries(string):
    d = {}

    RELEVANT_FIELDS = {'author','title'}

    SPECIAL_TYPES = {'comment','string','preamble'}

    between_cbrace_ex = r'(?:(?<rec>{(?<value>[^{}]+|(?P>rec))*+}))'

    field_match = re.compile(rf'(?<name>\w+)\s*=\s*({between_cbrace_ex}|"(?<value>[^"]+)"|(?<value>\d+))')
    entry_match = re.compile(rf'@(?<type>\w+)(?<value>{between_cbrace_ex})')
    key_match = re.compile(r'([^{},~#%\\]+),')

    for entry in entry_match.finditer(string):
        entry_type = entry['type'].lower()
        if entry_type not in SPECIAL_TYPES:
            key = key_match.search(entry['value'])[1]
            d[entry_type, key] = {
                field['name'].lower(): field['value']
                for field in field_match.finditer(entry['value'])
                if field['name'].lower() in RELEVANT_FIELDS
            }

    return d

def unbrace(expression):
    string_ls = []
    is_between_dollar_sign = False
    is_previous_backslash = False
    for c in expression:
        if c == '$' and not is_previous_backslash:
            if is_between_dollar_sign:
                is_between_dollar_sign = False
            else:
                is_between_dollar_sign = True
        if c == '\\':
            is_previous_backslash = True
        else:
            is_previous_backslash = False
        if c in '{}' and not is_between_dollar_sign:
            continue
        string_ls.append(c)
    return ''.join(string_ls)

def html_enclose(tag,string):
    return rf'<{tag.upper()}>{string}</{tag.upper()}>'

def html_create_span(expression):
    return html_enclose('span',expression)

def html_add_attr(attr,val,html_expression):
    return re.sub(r'<(\w+)([^>]*)\s*>(.*)</\1>',rf'<\1\2 {attr.upper()}="{val}">\3</\1>',html_expression)

def mult_replace(string, replacement_list):
    for old, new in replacement_list:
        string = re.sub(old, new, string)
    return string

def format_authors(data):
    for d in data.values():
        if "author" in d:
            author_lst = [ remove_consecutive_spaces(
                           str.strip(
                           invert_name(
                           unbrace(
                           remove_accents(name)))))
                           for name in re.split(r"\band\b", d["author"].replace("\n", " "))]
            d['author'] = [author for author in author_lst if author]

def remove_consecutive_spaces(name):
    return re.sub(r'\s+',' ',name)

def invert_name(author_name):
    return re.sub(r"([^,]+),\s*([^,]+)", r"\2 \1", author_name)

def remove_accents(name):
    return remove_latex_accent(remove_normal_accent(name))

def remove_latex_accent(name):
    return re.sub(r'\\\W','',name)

def remove_normal_accent(name):
    import unicodedata
    return ''.join((c for c in unicodedata.normalize('NFD', name) if unicodedata.category(c) != 'Mn'))

def fix_repeated_authors(data):
    author_blocks = fix_block_func(
                        block_authors_with_two_common_names_v2(
                            get_author_list(data)))

    author_dict = {author_name:max(s,key=len)
                   for s in author_blocks
                   for author_name in s}

    for d in data.values():
        d['author'] = [author_dict[author]
                       for author in d['author']]

def get_author_list(data):
    return sorted(set([a for s in data.values() for a in s.get("author", [])]))

def block_authors_with_two_common_names_v2(authors):
    res = set()
    for author in authors:
        fs = set()
        for author2 in authors:
            a1 = set(re.findall(r'\w\w+',author))
            a2 = set(re.findall(r'\w\w+',author2))

            if len(a1.intersection(a2)) > 1:
                fs.add(author2)

            elif len(a1) == 1 and len(a1.intersection(a2)) == 1 and is_a_first_last_match(author,author2):
                fs.add(author2)
        res.add(frozenset(fs))
    return res

def get_crude_abbrev(name):
    return ''.join(c for c in name if c.isupper())

def is_a_first_last_match(author1,author2):
    a1 = get_crude_abbrev(author1)
    a2 = get_crude_abbrev(author2)
    return a1[0] == a2[0] and a1[-1] == a2[-1]

def fix_block_func(data):
    res = set()
    for q in data:
        for s2 in data:
            if q.intersection(s2) != set():
                q = q.union(s2)
        res.add(frozenset(q))
    return res

def get_pub_type_counts(data):
    pub_types_occur = [x[0] for x in data.keys()]
    pub_types = set(pub_types_occur)
    return [(pub_type, pub_types_occur.count(pub_type)) for pub_type in pub_types]

def get_html_pub_type_counts(data):
    string_ls = [html_enclose('h2',
                              'Number of Occurrences of Publication Types')]
    pub_counts = sorted(
        get_pub_type_counts(data),
        key=lambda x: x[1],reverse=True)

    time = lambda v: 's' if v > 1 else ''
    for pub_type, count in pub_counts:
        string_ls.append(
            html_enclose('p',
                         f'Type {pub_type} appears {count} time{time(count)}'
            )
        )

    return ''.join(string_ls)

def get_author_pub_graph(author,data):
    pub_partners = []
    for entry in data.values():
        if 'author' in entry and author in entry['author']:
            for partner in entry['author']:
                if partner != author:
                    pub_partners.append(partner)
    return [(author_name,pub_partners.count(author_name))
            for author_name in set(pub_partners)]

def get_dot_graph(author,data):
    import textwrap
    g = sorted(get_author_pub_graph(author,data),key = lambda x: x[1])
    string_ls = ['graph{']
    string_ls2 = []
    for partner_author,no_joint_pub in g[-3:]:
        string_ls2.append(f'"{author}" -- "{partner_author}" [label="{no_joint_pub}"]')
    string_ls.append(textwrap.indent('\n'.join(string_ls2),'  '))
    string_ls.append('}')
    return '\n'.join(string_ls)

def get_html_dot_svg(author,data):
    import os
    DOT_INPUT_FILENAME = 'dot_input'
    with open(DOT_INPUT_FILENAME,'w') as file:
        file.write(get_dot_graph(author,data))
    os.system(f'dot -T svg -O {DOT_INPUT_FILENAME}')
    with open(DOT_INPUT_FILENAME + '.svg','r') as file:
        return re.search(r'<svg(?:.|\n)+</svg>',file.read()).group()

def get_html_common_pub_author(author,data):
    string_ls = [html_enclose('h2','Author Graph')]
    string_ls.append(get_html_dot_svg(author,data))
    return ''.join(string_ls)

def fix_title(title):
    substitutions = [(r'\\textsc{((?:\\{|[^{])+)}',
                      lambda m: f'{html_to_small_caps(html_create_span(m.group(1)))}'),
                     (r'\\textsf{((?:\\{|[^{])+)}',
                      lambda m: f'{html_to_sans_serif(html_create_span(m.group(1)))}'),
                     (r'(\$(?:.|\\\$)+\$)',
                      lambda m: f'{str_to_html_math(m.group(1))}')]


    replace = lambda x: mult_replace(x,substitutions)

    return   html_create_span(
             single_quote_latex(
             double_quote_latex(
             unbrace(
             replace(
             remove_latex_special_chars(
             ' '.join(s.strip() for s in title.split('\n'))))))))

def double_quote_latex(expression):
    return re.sub(r"``(.*[^\\])''",r'"\1"',expression)

def single_quote_latex (expression):
    return re.sub(r"[^`]`([^`].*[^'])'[^`]",r"'\1'",expression)

def remove_latex_special_chars(latex_expression):
    return re.sub(r'\\({|[^{])\b',r'\1',latex_expression)

def html_to_small_caps(html_expression):
    return html_add_attr('style','font-variant:small-caps',html_expression)

def str_to_html_small_caps(expression):
    return html_to_small_caps(html_create_span(expression))

def html_to_sans_serif(html_expression):
    return html_add_attr('style','font-family:sans-serif',html_expression)

def str_to_html_math(string):
    return html_add_attr('class','math inline',html_create_span(string))

def get_html_pub_type_index(data):
    string_ls = [html_enclose('h2','Publication Type Index')]
    for entry_type in sorted(set(x[0] for x in data)):
        string_ls.append(html_enclose('h3',entry_type))
        for citation_key in [x[1] for x in data if x[0]==entry_type]:
            title = data[entry_type,citation_key].get('title','')
            authors = ', '.join((sorted(data[entry_type,citation_key].get('author',''))))
            string_ls.append(
                html_enclose('p',
                             f"Key = {citation_key}<br>Title = {fix_title(title)}<br>Autores = {authors}"))

    return '\n'.join(string_ls)

def last_name_first(name):
    initials =  '. '.join(get_crude_abbrev(name))[:-2]
    last_name = name.split()[-1]
    return f'{last_name}, {initials}'

def get_author_index_dict(data):
    index = {}
    for key, e in data.items():
        if 'author' in e:
            for author in e['author']:
                author_name = last_name_first(author)
                if author_name not in index:
                    index[author_name] = set()
                index[author_name].add(key[1])
    return index

def get_html_author_index(data):
    index = sorted(get_author_index_dict(data).items())
    alphabet_order = sorted(set(c[0][0] for c in index))
    string_ls = [html_enclose('h2','Author Index')]
    i = 0
    string_ls.append(html_enclose('h3',alphabet_order[i]))
    for author,citation_keys in index:
        if author[0] != alphabet_order[i]:
            i += 1
            string_ls.append(html_enclose('h3',alphabet_order[i]))
        citation_keys_str = ', '.join(citation_keys)
        string_ls.append(html_enclose('p',f'{author}, {citation_keys_str}'))
    return '\n'.join(string_ls)

if __name__ == '__main__':
    import sys
    import os.path

    filename = sys.argv[1] if len(sys.argv) > 1 else BIB_EXAMPLE_FILENAME
    assert os.path.isfile(filename)

    if len(sys.argv) < 3:
        author_name = 'Daniela da Cruz'
    else:
        author_name = sys.argv[2]
    solve(author_name,filename)
```

### _HTML_ Output

```html
<!DOCTYPE  html>
    <HTML lang="en">
        <HEAD>
            <meta charset="utf-8">
            <TITLE>Categories in BibTeX</TITLE>

            <script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                    "extensions":["tex2jax.js"],
                    "jax":["input/TeX",
                           "output/HTML-CSS"],
                    "messageStyle":"none",
                    "tex2jax":{
                        "processEnvironments":false,
                        "processEscapes":true,
                        "inlineMath":[["$","$"]],
                        "displayMath":[]
                    },
                    "TeX":{
                        "extensions":["AMSmath.js",
                                      "AMSsymbols.js",
                                      "noErrors.js",
                                      "noUndefined.js"]
                    },
                    "HTML-CSS":{
                        "availableFonts":["TeX"]
                    }
                });
            </script>

            <script type="text/javascript" async
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js">
            </script>

        </HEAD>
<BODY><H2>Number of Occurrences of Publication Types</H2><P>Type inproceedings appears 112 times</P><P>Type article appears 33 times</P><P>Type techreport appears 11 times</P><P>Type incollection appears 5 times</P><P>Type mastersthesis appears 1 time</P><P>Type book appears 1 time</P><P>Type misc appears 1 time</P><P>Type phdthesis appears 1 time</P><H2>Author Graph</H2><svg width="578pt" height="131pt"
 viewBox="0.00 0.00 577.59 131.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 127)">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-127 573.59,-127 573.59,4 -4,4"/>
<!-- Daniela da Cruz -->
<g id="node1" class="node">
<title>Daniela da Cruz</title>
<ellipse fill="none" stroke="black" cx="249.74" cy="-105" rx="68.49" ry="18"/>
<text text-anchor="middle" x="249.74" y="-101.3" font-family="Times,serif" font-size="14.00">Daniela da Cruz</text>
</g>
<!-- Nuno Oliveira -->
<g id="node2" class="node">
<title>Nuno Oliveira</title>
<ellipse fill="none" stroke="black" cx="61.74" cy="-18" rx="61.99" ry="18"/>
<text text-anchor="middle" x="61.74" y="-14.3" font-family="Times,serif" font-size="14.00">Nuno Oliveira</text>
</g>
<!-- Daniela da Cruz&#45;&#45;Nuno Oliveira -->
<g id="edge1" class="edge">
<title>Daniela da Cruz&#45;&#45;Nuno Oliveira</title>
<path fill="none" stroke="black" d="M217,-89.19C182.39,-73.55 128.15,-49.02 93.8,-33.49"/>
<text text-anchor="middle" x="174.74" y="-57.8" font-family="Times,serif" font-size="14.00">11</text>
</g>
<!-- Maria Joao Varanda Pereira -->
<g id="node3" class="node">
<title>Maria Joao Varanda Pereira</title>
<ellipse fill="none" stroke="black" cx="249.74" cy="-18" rx="108.58" ry="18"/>
<text text-anchor="middle" x="249.74" y="-14.3" font-family="Times,serif" font-size="14.00">Maria Joao Varanda Pereira</text>
</g>
<!-- Daniela da Cruz&#45;&#45;Maria Joao Varanda Pereira -->
<g id="edge2" class="edge">
<title>Daniela da Cruz&#45;&#45;Maria Joao Varanda Pereira</title>
<path fill="none" stroke="black" d="M249.74,-86.8C249.74,-72.05 249.74,-50.92 249.74,-36.18"/>
<text text-anchor="middle" x="256.74" y="-57.8" font-family="Times,serif" font-size="14.00">25</text>
</g>
<!-- Pedro Rangel Henriques -->
<g id="node4" class="node">
<title>Pedro Rangel Henriques</title>
<ellipse fill="none" stroke="black" cx="472.74" cy="-18" rx="96.68" ry="18"/>
<text text-anchor="middle" x="472.74" y="-14.3" font-family="Times,serif" font-size="14.00">Pedro Rangel Henriques</text>
</g>
<!-- Daniela da Cruz&#45;&#45;Pedro Rangel Henriques -->
<g id="edge3" class="edge">
<title>Daniela da Cruz&#45;&#45;Pedro Rangel Henriques</title>
<path fill="none" stroke="black" d="M286.82,-89.87C326.95,-74.57 390.74,-50.26 432.18,-34.46"/>
<text text-anchor="middle" x="381.74" y="-57.8" font-family="Times,serif" font-size="14.00">39</text>
</g>
</g>
</svg><H2>Publication Type Index</H2>
<H3>article</H3>
<P>Key = jj96<br>Title = <SPAN>NLlex -- a tool to generate lexical analysers for natural language</SPAN><br>Autores = Jose Joao Dias de Almeida</P>
<P>Key = Ramalho98<br>Title = <SPAN>Algebraic specification of documents</SPAN><br>Autores = Jose Carlos Ramalho, Jose Joao Dias de Almeida, Pedro Rangel Henriques</P>
<P>Key = RRAH99<br>Title = <SPAN>SGML documents: Where does quality go?</SPAN><br>Autores = Jorge Gustavo Rocha, Jose Carlos Ramalho, Jose Joao Dias de Almeida, Pedro Rangel Henriques</P>
<P>Key = speaker:sepln2001<br>Title = <SPAN>Text to speech -- a rewriting system approach</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = parguess2002<br>Title = <SPAN>Grabbing parallel corpora from the web</SPAN><br>Autores = Alberto Manuel Brandao Simoes, J. Alves de Castro, Jose Joao Dias de Almeida</P>
<P>Key = sepln2003<br>Title = <SPAN>NATools -- A Statistical Word Aligner Workbench</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = xmldt2<br>Title = <SPAN>- Down-Translating XML</SPAN><br>Autores = Alberto Manuel Brandao Simoes</P>
<P>Key = sepln2004<br>Title = <SPAN>Distributed Translation Memories implementation using WebServices</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida, Xavier Gomez Guinovart</P>
<P>Key = sepln06<br>Title = <SPAN>A Client-Server Architecture for building Parallel Corpora applications</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = KMHVZ04<br>Title = <SPAN>Grammatical Approach to Problem Solving</SPAN><br>Autores = Maria Joao Varanda Pereira, Marjan Mernik, Pedro Rangel Henriques, Tomaz Kosar, Viljem Zumer</P>
<P>Key = HVMLGW05<br>Title = <SPAN>Automatic Generation of Language-based Tools using LISA System</SPAN><br>Autores = Hui Wu, Jeff Gray, Maria Joao Varanda Pereira, Marjan Mernik, Mitja Lenic, Pedro Rangel Henriques</P>
<P>Key = RMHV06<br>Title = <SPAN>AspectLISA: an aspect-oriented compiler construction system based on attribute grammars</SPAN><br>Autores = Damijan Rebernak, Maria Joao Varanda Pereira, Marjan Mernik, Pedro Rangel Henriques</P>
<P>Key = RMHCV06<br>Title = <SPAN>Specifying Languages using aspect-oriented approach: AspectLISA</SPAN><br>Autores = Damijan Rebernak, Daniela da Cruz, Maria Joao Varanda Pereira, Marjan Mernik, Pedro Rangel Henriques</P>
<P>Key = GDH06<br>Title = <SPAN>AG-based interactive system to retrieve information from XML documents</SPAN><br>Autores = Alda Lopes Gancarski, Anne Doucet, Pedro Rangel Henriques</P>
<P>Key = BH98<br>Title = <SPAN>A Framework and Patterns for the   Specification of Reactive Systems</SPAN><br>Autores = Leonor Barroca, Pedro Rangel Henriques</P>
<P>Key = RAH98<br>Title = <SPAN>Algebraic Specification of Documents</SPAN><br>Autores = Jose Carlos Ramalho, Jose Joao Dias de Almeida, Pedro Rangel Henriques</P>
<P>Key = RARH98<br>Title = <SPAN>SGML Documents: Where does quality go?</SPAN><br>Autores = Jorge Gustavo Rocha, Jose Carlos Ramalho, Jose Joao Dias de Almeida, Pedro Rangel Henriques</P>
<P>Key = GRH06<br>Title = <SPAN>Metamorphosis - A Topic Maps Based Environment to Handle Heterogeneous Information Resources</SPAN><br>Autores = Giovani Rubert Librelotto, Jose Carlos Ramalho, Pedro Rangel Henriques</P>
<P>Key = JGRH04<br>Title = <SPAN>XCSL Tutorial</SPAN><br>Autores = Giovani Rubert Librelotto, Jose Carlos Ramalho, Marta Jacinto, Pedro Rangel Henriques</P>
<P>Key = JGRH03<br>Title = <SPAN>XCSL: XML Constraint Specification Language</SPAN><br>Autores = Giovani Rubert Librelotto, Jose Carlos Ramalho, Marta Jacinto, Pedro Rangel Henriques</P>
<P>Key = GRH04<br>Title = <SPAN>TM-Builder: An Ontology Builder based on XML Topic Maps</SPAN><br>Autores = Giovani Rubert Librelotto, Jose Carlos Ramalho, Pedro Rangel Henriques</P>
<P>Key = GRH05a<br>Title = <SPAN>Geração automática de interfaces Web para Sistemas de Informação: Metamorphosis</SPAN><br>Autores = Giovani Rubert Librelotto, Jose Carlos Ramalho, Pedro Rangel Henriques</P>
<P>Key = RH98a<br>Title = <SPAN>Qualidade na Publicação Electrónica: como controlá-la?</SPAN><br>Autores = Jose Carlos Ramalho, Pedro Rangel Henriques</P>
<P>Key = MSH05<br>Title = <SPAN>Utilizando uma Base de Dados XML Nativa aplicada ao tratamento de erros num sistema de logs</SPAN><br>Autores = Giovana Mendes, Nuno Alberto Silva, Pedro Rangel Henriques</P>
<P>Key = ALHF02<br>Title = <SPAN>O Uso da Linguagem RS em Robótica</SPAN><br>Autores = Giovani Rubert Librelotto, Gustavo Arnold, Jaime Fonseca, Pedro Rangel Henriques</P>
<P>Key = CHV08ja<br>Title = <SPAN>Alma versus DDD</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Pedro Rangel Henriques</P>
<P>Key = FPCH08jb<br>Title = <SPAN>Language in a Model-Based Engineering Environment for Control Systems -- An Approach for Compiler Implementation</SPAN><br>Autores = Daniela da Cruz, Elisabete Ferreira, Pedro Rangel Henriques, Rogerio Paulo</P>
<P>Key = PMCH08j<br>Title = <SPAN>Program Comprehension for Domain-Specific Languages (invited paper)</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Marjan Mernik, Pedro Rangel Henriques</P>
<P>Key = CHV07<br>Title = <SPAN>Constructing program animations using a pattern-based approach</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Pedro Rangel Henriques</P>
<P>Key = LARH09<br>Title = <SPAN>Topic Maps Constraint Languages: understanding and comparing</SPAN><br>Autores = Giovani Rubert Librelotto, Jose Carlos Ramalho, Pedro Rangel Henriques, Renato Preigschadt de Azevedo</P>
<P>Key = CBHP09<br>Title = <SPAN>Code Inspection Approaches for Program Visualization</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques</P>
<P>Key = OPHCC2010<br>Title = <SPAN>VisualLISA: A Visual Environment to Develop Attribute Grammars</SPAN><br>Autores = Bastian Cramer, Daniela da Cruz, Maria Joao Varanda Pereira, Nuno Oliveira, Pedro Rangel Henriques</P>
<P>Key = KOMPCCH2010<br>Title = <SPAN>Comparing General-Purpose and Domain-Specific Languages: An Empirical Study</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Marjan Mernik, Matej Crepinsek, Nuno Oliveira, Pedro Rangel Henriques, Tomaz Kosar</P>
<H3>book</H3>
<P>Key = RH02<br>Title = <SPAN>XML \& XSL: da teoria à prática</SPAN><br>Autores = Jose Carlos Ramalho, Pedro Rangel Henriques</P>
<H3>incollection</H3>
<P>Key = avalon:jspell<br>Title = <SPAN>nas Morfolimpíadas</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = avalon:avalinha<br>Title = <SPAN>Avaliação de alinhadores</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = harem:rena<br>Title = <SPAN>- Reconhecedor de Entidades</SPAN><br>Autores = Jose Joao Dias de Almeida</P>
<P>Key = RRH02<br>Title = <SPAN>Data Reduction to Improve Knowledge Extraction</SPAN><br>Autores = Carlos Ramos, Maria de Fatima Rodrigues, Pedro Rangel Henriques</P>
<P>Key = ORH06<br>Title = <SPAN>Data Cleaning by Reusing Domain Knowledge</SPAN><br>Autores = Maria de Fatima Rodrigues, Paulo Oliveira, Pedro Rangel Henriques</P>
<H3>inproceedings</H3>
<P>Key = graminteractivas1990<br>Title = <SPAN>Mecanismos para Especificação e Prototipagem de Interfaces Utilizador-Sistema</SPAN><br>Autores = F. Mario Martins, Jose Joao Dias de Almeida, Pedro Rangel Henriques</P>
<P>Key = Almeida94b<br>Title = <SPAN>GPC -- a Tool for higher-order grammar specification</SPAN><br>Autores = Jose Joao Dias de Almeida</P>
<P>Key = Almeida95a<br>Title = <SPAN>YaLG -- extending DCG for natural language processing</SPAN><br>Autores = Jose Joao Dias de Almeida</P>
<P>Key = Almeida94c<br>Title = <SPAN>Jspell -- um módulo para análise léxica genérica de linguagem natural</SPAN><br>Autores = Jose Joao Dias de Almeida, Ulisses Pinto</P>
<P>Key = Ramalho95<br>Title = <SPAN>Algebraic Specification of Documents</SPAN><br>Autores = Jose Carlos Ramalho, Jose Joao Dias de Almeida, Pedro Rangel Henriques</P>
<P>Key = Almeida96a<br>Title = <SPAN>Especificação e tratamento de Dicionários</SPAN><br>Autores = Jose Joao Dias de Almeida</P>
<P>Key = Ulisses96<br>Title = <SPAN>Tratamento automático de termos compostos</SPAN><br>Autores = Jose Joao Dias de Almeida, Ulisses Pinto</P>
<P>Key = Almeida96b<br>Title = <SPAN>YaLG a tool for higher-order grammar specification</SPAN><br>Autores = J.B. Barros, Jose Joao Dias de Almeida</P>
<P>Key = Ramalho96<br>Title = <SPAN>Document Semantics: two approaches</SPAN><br>Autores = Jose Carlos Ramalho, Jose Joao Dias de Almeida, Pedro Rangel Henriques</P>
<P>Key = SGML97<br>Title = <SPAN>SGML Documents: where does quality go?</SPAN><br>Autores = Jorge Gustavo Rocha, Jose Carlos Ramalho, Jose Joao Dias de Almeida, Pedro Rangel Henriques</P>
<P>Key = Almeida98<br>Title = <SPAN>Programação de dicionários</SPAN><br>Autores = Jose Joao Dias de Almeida</P>
<P>Key = Reis98<br>Title = <SPAN>Etiquetador morfo-sintáctico para o Português</SPAN><br>Autores = Jose Joao Dias de Almeida, Ricardo Reis</P>
<P>Key = ABNO97a<br>Title = <SPAN><SPAN STYLE="font-variant:small-caps">Camila</SPAN>: Formal Software Engineering Supported by Functional Programming</SPAN><br>Autores = F.L. Neves, J.N. Oliveira, Jose Joao Dias de Almeida, L.S. Barbosa</P>
<P>Key = ABNO97b<br>Title = <SPAN><SPAN STYLE="font-variant:small-caps">Camila</SPAN>: Prototyping and Refinement of Constructive Specifications</SPAN><br>Autores = F.L. Neves, J.N. Oliveira, Jose Joao Dias de Almeida, L.S. Barbosa</P>
<P>Key = AH97<br>Title = <SPAN>Dynamic Dictionary = cooperative information sources</SPAN><br>Autores = Jose Joao Dias de Almeida, Pedro Rangel Henriques</P>
<P>Key = museums98<br>Title = <SPAN>Adapting Museum Structures for the Web: No Changes Needed!</SPAN><br>Autores = J.L. Faria, Jorge Gustavo Rocha, Jose Carlos Ramalho, Jose Joao Dias de Almeida, Mario Ricardo Henriques, Pedro Rangel Henriques</P>
<P>Key = ABBN98<br>Title = <SPAN>On The Development of <SPAN STYLE="font-variant:small-caps">Camila</SPAN></SPAN><br>Autores = J.B. Barros, Jose Joao Dias de Almeida, L.F. Neves, L.S. Barbosa</P>
<P>Key = Gis99<br>Title = <SPAN>Systems Development</SPAN><br>Autores = Ana Silva, Jorge Gustavo Rocha, Jose Joao Dias de Almeida, Mario Ricardo Henriques, Pedro Rangel Henriques</P>
<P>Key = RPA99<br>Title = <SPAN>Maps</SPAN><br>Autores = Jorge Gustavo Rocha, Jose Joao Dias de Almeida, Tiago Pedroso</P>
<P>Key = RSea99<br>Title = <SPAN>SIG</SPAN><br>Autores = Ana Silva, Jorge Gustavo Rocha, Jose Joao Dias de Almeida, Mario Ricardo Henriques, Pedro Rangel Henriques</P>
<P>Key = xmldt99<br>Title = <SPAN>a Perl Down-Translation module</SPAN><br>Autores = Jose Carlos Ramalho, Jose Joao Dias de Almeida</P>
<P>Key = Barbosa2000<br>Title = <SPAN>Polytypic Recursion Patterns</SPAN><br>Autores = J.B. Barros, Jose Joao Dias de Almeida, L.S. Barbosa</P>
<P>Key = jj2001x<br>Title = <SPAN>Smallbook -- comando para produção de livros em pequena escala</SPAN><br>Autores = Jose Joao Dias de Almeida</P>
<P>Key = mp2001<br>Title = <SPAN>-- Arquitectura</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jorge Gustavo Rocha, Jose Joao Dias de Almeida, Pedro Rangel Henriques, Sonia Moreira</P>
<P>Key = alfarrabio2001<br>Title = <SPAN>Alfarrábio: Adding value to an Heterogeneous Site Collection</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jorge Gustavo Rocha, Jose Joao Dias de Almeida, Pedro Rangel Henriques</P>
<P>Key = freq2002<br>Title = <SPAN>Cálculo de frequências de palavras para entradas de dicionários através do uso conjunto de analisadores morfológicos, taggers e corpora</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida, Paulo A. Rocha</P>
<P>Key = jspell2002<br>Title = <SPAN>Jspell.pm -- um módulo de análise morfológica para uso em processamento de linguagem natural</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = dag2002<br>Title = <SPAN>Directory Attribute Grammars</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida, Pedro Rangel Henriques</P>
<P>Key = elpub2002<br>Title = <SPAN>Library::* -- a toolkit for digital libraries</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = APL2k2.Parguess<br>Title = <SPAN>Extracção de corpora paralelo a partir da web: construção e disponibilização</SPAN><br>Autores = Alberto Manuel Brandao Simoes, J. Alves de Castro, Jose Joao Dias de Almeida</P>
<P>Key = APL2k2.Synthesis<br>Title = <SPAN>Geração de voz com sotaque</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = xata:xmldt<br>Title = <SPAN>Engenharia reversa de HTML usando tecnologia XML</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = xata:museudapessoa<br>Title = <SPAN>essoa</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = elpub2003<br>Title = <SPAN>Music publishing</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = cp3a:terminum2003<br>Title = <SPAN>Projecto TerminUM</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Bruno Martins, J. Alves de Castro, Jose Joao Dias de Almeida, Paulo Silva</P>
<P>Key = cp3a:kvec2003<br>Title = <SPAN>Lingua-Biterm: um módulo Perl para extracção de terminologia bilingue</SPAN><br>Autores = Bruno Martins</P>
<P>Key = cp3a:natools2003<br>Title = <SPAN>Alinhamento de corpora paralelos</SPAN><br>Autores = Alberto Manuel Brandao Simoes</P>
<P>Key = xata04:tx<br>Title = <SPAN>baseada em tipos dinâmicos</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = xata04:mtd<br>Title = <SPAN>Memórias de Tradução Distribuídas</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida, Xavier Gomez Guinovart</P>
<P>Key = linguateca<br>Title = <SPAN>Linguateca: um centro de recursos distribuído para o processamento computacional da língua portuguesa</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Ana Frankenberg-Garcia, Ana Pinto, Anabela Barreiro, Belinda Maia, Cristina Mota, Debora Oliveira, Diana Santos, Eckhard Bick, Elisabete Ranchhod, Jose Joao Dias de Almeida, Luis Cabral, Luis Costa, Luis Sarmento, Marcirio Chaves, Nuno Cardoso, Paulo A. Rocha, Rachel Aires, Rosario Silva, Rui Vilela, Susana Afonso</P>
<P>Key = xata05:fs<br>Title = <SPAN>Representação em XML da Floresta Sintáctica</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Eckhard Bick, Jose Joao Dias de Almeida, Rui Vilela</P>
<P>Key = xata05:tdt<br>Title = <SPAN>Inferência de tipos em documentos XML</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = xata06:navegante<br>Title = <SPAN>Navegante: um proxy de ordem superior para navegação intusiva</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = xata06:xmlauto<br>Title = <SPAN>XML</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = eamt06<br>Title = <SPAN>Combinatory Examples Extraction for Machine Translation</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = lrec06<br>Title = <SPAN>--- Recycling Thesauri into a Multilingual Ontology</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = elpub06-t2o<br>Title = <SPAN>Publishing multilingual ontologies: a quick way of obtaining feedback</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = elpub06-blind<br>Title = <SPAN>Transcoding for Web Accessibility for the Blind: Semantics from Structure</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Alexandre Carvalho, Antonio R. Fernandes, Jose Joao Dias de Almeida</P>
<P>Key = xata07:xmltmx<br>Title = <SPAN>--- Processamento de Memórias de Tradução de Grandes Dimensões</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida</P>
<P>Key = MP07<br>Title = <SPAN>Dependency Specification Language</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Jose Joao Dias de Almeida, Ruben Fonseca</P>
<P>Key = epia-bio-2007<br>Title = <SPAN>An Ontology-Based Approach To Systems Biology Literature Retrieval and Processing</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Analia Lourenco, Eugenio Ferreira, Isabel Rocha, Jose Joao Dias de Almeida, Miguel Rocha</P>
<P>Key = epia-music-2007<br>Title = <SPAN>Using Text Mining Techniques for Classical Music Scores Analysis</SPAN><br>Autores = Alberto Manuel Brandao Simoes, Analia Lourenco, Jose Joao Dias de Almeida</P>
<P>Key = HKMVZ03<br>Title = <SPAN>Grammatical Approach to Problem Solving</SPAN><br>Autores = Maria Joao Varanda Pereira, Marjan Mernik, Pedro Rangel Henriques, Tomaz Kosar, Viljem Zumer</P>
<P>Key = VH01<br>Title = <SPAN>Visualization / Animation of Programs based on Abstract Representations and Formal Mappings</SPAN><br>Autores = Maria Joao Varanda Pereira, Pedro Rangel Henriques</P>
<P>Key = VH02<br>Title = <SPAN>Automatic Generation of Language-based Tools</SPAN><br>Autores = Maria Joao Varanda Pereira, Marjan Mernik, Mitja Lenic, Pedro Rangel Henriques</P>
<P>Key = VH03<br>Title = <SPAN>Visualization / Animation of Programs in Alma: obtaining different results</SPAN><br>Autores = Maria Joao Varanda Pereira, Pedro Rangel Henriques</P>
<P>Key = RMHVC06<br>Title = <SPAN>Specifying Languages using Aspect-oriented Approach: AspectLISA</SPAN><br>Autores = Damijan Rebernak, Daniela da Cruz, Maria Joao Varanda Pereira, Marjan Mernik, Pedro Rangel Henriques</P>
<P>Key = BHVU07d<br>Title = <SPAN>PICS una Herramienta para la Comprensión e Inspección de Programas</SPAN><br>Autores = Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques, Roberto Uzal</P>
<P>Key = BHVU07c<br>Title = <SPAN>Program Inspection to Incerconnect Behavioral and Operational View for Program Comprehension</SPAN><br>Autores = Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques, Roberto Uzal</P>
<P>Key = BHVU07b<br>Title = <SPAN>Comprensi'on de Programas por Inspecci'on Visual y Animaci'on</SPAN><br>Autores = Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques, Roberto Uzal</P>
<P>Key = BHVU07a<br>Title = <SPAN>Static and Dynamic Strategies to Understand C Programs by Code Annotation</SPAN><br>Autores = Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques, Roberto Uzal</P>
<P>Key = CHLB07a<br>Title = <SPAN>O Sitio de Pico, Software Educativo para Crianças con Paralisia Cerebral</SPAN><br>Autores = Elisabete Cunha, Mario Beron, Pedro Rangel Henriques, Sandra Cristina Lopes</P>
<P>Key = BHVU06a<br>Title = <SPAN>Herramientas para la compresión de programas</SPAN><br>Autores = Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques, Roberto Uzal</P>
<P>Key = BHVU06b<br>Title = <SPAN>Comprensión de Algoritmos de Ruteo</SPAN><br>Autores = Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques, Roberto Uzal</P>
<P>Key = BHVUM06<br>Title = <SPAN>A Language Processing Tool for Program Comprehension</SPAN><br>Autores = G. Montejano, Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques, Roberto Uzal</P>
<P>Key = BHVU08<br>Title = <SPAN>Simplificando la Comprensión de Programas a través de la Interconnexión de Dominios</SPAN><br>Autores = Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques, Roberto Uzal</P>
<P>Key = BHV06<br>Title = <SPAN>A System for Evaluate and Understand Routing Algorithms</SPAN><br>Autores = Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques</P>
<P>Key = BCVHU08<br>Title = <SPAN>Evaluation Criteria of Software Visualization Systems used for Program Comprehension</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques, Roberto Uzal</P>
<P>Key = BUHV08<br>Title = <SPAN>Inspección de Código para relacionar los Dominios del Problema y Programa para la Comprensión de Programas</SPAN><br>Autores = Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques, Roberto Uzal</P>
<P>Key = OVH05<br>Title = <SPAN>Compreensão de Aplicações Web: O Processo e as Ferramentas</SPAN><br>Autores = Eva Oliveira, Maria Joao Varanda Pereira, Pedro Rangel Henriques</P>
<P>Key = OHV06<br>Title = <SPAN>Proposta de um Sistema para Compreensão de Aplicações Web</SPAN><br>Autores = Eva Oliveira, Maria Joao Varanda Pereira, Pedro Rangel Henriques</P>
<P>Key = GH07b<br>Title = <SPAN>Analyzing the structure of scientific articles to improve information retrieval</SPAN><br>Autores = Alda Lopes Gancarski, Pedro Rangel Henriques</P>
<P>Key = GH07a<br>Title = <SPAN>Using data together with metadata to improve XML information access</SPAN><br>Autores = Alda Lopes Gancarski, Pedro Rangel Henriques</P>
<P>Key = GFH08<br>Title = <SPAN>Using data together with metadata to improve XML information access</SPAN><br>Autores = Alda Lopes Gancarski, Flavio Xavier Ferreira, Pedro Rangel Henriques</P>
<P>Key = FGH08<br>Title = <SPAN>Information access from XML using semantics and context: application to the Portuguese Emigration Museum</SPAN><br>Autores = Alda Lopes Gancarski, Flavio Xavier Ferreira, Pedro Rangel Henriques</P>
<P>Key = FH08<br>Title = <SPAN>Using OWL to specify and build different views over the Emigration Museum resources</SPAN><br>Autores = Flavio Xavier Ferreira, Pedro Rangel Henriques</P>
<P>Key = LPRH07<br>Title = <SPAN>Navegando na Rede Semântica dos Topic Maps com o Ulisses</SPAN><br>Autores = Giovani Rubert Librelotto, Jose Carlos Ramalho, Pedro Rangel Henriques, Renato Preigschadt de Azevedo</P>
<P>Key = LPRH07-TM<br>Title = <SPAN>Topic Maps Constraint Specification Languages: comparing AsTMa!, OSL, and XTche</SPAN><br>Autores = Giovani Rubert Librelotto, Jose Carlos Ramalho, Pedro Rangel Henriques, Renato Preigschadt de Azevedo</P>
<P>Key = LRHGT08<br>Title = <SPAN>A Framework to specify, extract and manage Topic Maps driven by ontologie</SPAN><br>Autores = Giovani Rubert Librelotto, Jonas Bulegon Gassen, Jose Carlos Ramalho, Pedro Rangel Henriques, Rogerio Correa Turchetti</P>
<P>Key = LGFSSAH08<br>Title = <SPAN>Uma Ontologia aplicada a um Ambiente Pervasivo Hospitalar</SPAN><br>Autores = Fabio L. Silva, Giovani Rubert Librelotto, Iara Augustin, Jonas Bulegon Gassen, Leandro O. Freitas, Matheus C. Silveira, Pedro Rangel Henriques</P>
<P>Key = LMMVRH08<br>Title = <SPAN>Generating a Semantic Network for PubMed</SPAN><br>Autores = Giovani Rubert Librelotto, Henrique Machado, Jose Carlos Ramalho, Juliana Vizzotto, Mirkos Martins, Pedro Rangel Henriques</P>
<P>Key = CPH07f<br>Title = <SPAN>Pattern-based Program Visualization</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Pedro Rangel Henriques</P>
<P>Key = CH07g<br>Title = <SPAN>Slicing wxHaskell modules to derive the User Interface Abstract Model (short paper and poster)</SPAN><br>Autores = Daniela da Cruz, Pedro Rangel Henriques</P>
<P>Key = CH07h<br>Title = <SPAN>Laboratory Site (poster)</SPAN><br>Autores = Daniela da Cruz, Pedro Rangel Henriques</P>
<P>Key = FCHV08<br>Title = <SPAN>How to interconnect operational and behavioral views of web applications</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Pedro Rangel Henriques, Ruben Fonseca</P>
<P>Key = CHP08i<br>Title = <SPAN>Strategies for Program Inspection and Visualization</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Pedro Rangel Henriques</P>
<P>Key = CH07a<br>Title = <SPAN>anguage</SPAN><br>Autores = Daniela da Cruz, Pedro Rangel Henriques</P>
<P>Key = CLH07c<br>Title = <SPAN>Como ensinar com Mapas de Conceitos: duas abordagens complementares</SPAN><br>Autores = Daniela da Cruz, Pedro Rangel Henriques, Sandra Cristina Lopes</P>
<P>Key = CH07d<br>Title = <SPAN>LISS --- The language and the compiler</SPAN><br>Autores = Daniela da Cruz, Pedro Rangel Henriques</P>
<P>Key = CFPBH07d<br>Title = <SPAN>Comparing Generators for Language-based Tools</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques, Ruben Fonseca</P>
<P>Key = CHP08a<br>Title = <SPAN>Documents</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Pedro Rangel Henriques</P>
<P>Key = CHP08b<br>Title = <SPAN>DDD</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Pedro Rangel Henriques</P>
<P>Key = CPH08c<br>Title = <SPAN>Properties Preservation during Transformation (short paper)</SPAN><br>Autores = Daniela da Cruz, Jorge Sousa Pinto, Pedro Rangel Henriques</P>
<P>Key = FPCH08d<br>Title = <SPAN>Language in a Model-Based Engineering Environment for Control Systems --- An Approach for Compiler Implementation</SPAN><br>Autores = Daniela da Cruz, Elisabete Ferreira, Pedro Rangel Henriques, Rogerio Paulo</P>
<P>Key = PMCH08e<br>Title = <SPAN>: a Visual Interface for an Attribute Grammar based Compiler-Compiler (short paper)</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Marjan Mernik, Pedro Rangel Henriques</P>
<P>Key = PMCH08f<br>Title = <SPAN>Program Comprehension for Domain-Specific Languages</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Marjan Mernik, Pedro Rangel Henriques</P>
<P>Key = CHP09a<br>Title = <SPAN>Code Analysis: Past and Present</SPAN><br>Autores = Daniela da Cruz, Jorge Sousa Pinto, Pedro Rangel Henriques</P>
<P>Key = OPCH09a<br>Title = <SPAN>Visualization of Domain-Specific Programs' Behavior</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Nuno Oliveira, Pedro Rangel Henriques</P>
<P>Key = oliveira09b<br>Title = <SPAN>Applying Program Comprehension Techniques to Karel Robot Programs</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Marjan Mernik, Matej Crepinsek, Nuno Oliveira, Pedro Rangel Henriques, Tomaz Kosar</P>
<P>Key = oliveira09c<br>Title = <SPAN>VisualLISA: Visual Programming Environment for Attribute Grammars Specification</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Nuno Oliveira, Pedro Rangel Henriques</P>
<P>Key = kosar09<br>Title = <SPAN>Influence of domain-specific notation to program understanding</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Marjan Mernik, Nuno Oliveira, Pedro Rangel Henriques, Tomaz Kosar</P>
<P>Key = FCHGD09a<br>Title = <SPAN>A Query-by-Example Approach for XML Querying</SPAN><br>Autores = Alda Lopes Gancarski, Bruno Defude, Daniela da Cruz, Flavio Xavier Ferreira, Pedro Rangel Henriques</P>
<P>Key = ORH09a<br>Title = <SPAN>SMARTCLEAN: uma ferramenta para a limpeza incremental de dados</SPAN><br>Autores = Maria de Fatima Rodrigues, Paulo Jorge Oliveria, Pedro Rangel Henriques</P>
<P>Key = LPH09a<br>Title = <SPAN>Uma metodologia para Consultas aos Bancos de Dados do NCBI</SPAN><br>Autores = Giovani Rubert Librelotto, Pedro Rangel Henriques, Rafael Teodosio Pereira</P>
<P>Key = OPHC09a<br>Title = <SPAN>Domain Specific Languages: A Theoretical Survey</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Nuno Oliveira, Pedro Rangel Henriques</P>
<P>Key = OPHCC09<br>Title = <SPAN>: A Domain Specific Visual Language for Attribute Grammars</SPAN><br>Autores = Bastian Cramer, Daniela da Cruz, Maria Joao Varanda Pereira, Nuno Oliveira, Pedro Rangel Henriques</P>
<P>Key = MKCHCPO09<br>Title = <SPAN>Comparison of XAML and C\# Forms using Cognitive Dimensions Framework</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Marjan Mernik, Nuno Oliveira, Pedro Rangel Henriques, Tomaz Kosar</P>
<P>Key = OHCP09<br>Title = <SPAN>XAGra - An XML Dialect for Attribute Grammars</SPAN><br>Autores = Daniela da Cruz, Maria Joao Varanda Pereira, Nuno Oliveira, Pedro Rangel Henriques</P>
<P>Key = FCHGD09b<br>Title = <SPAN>GuessXQ, an inference Web-engine for querying XML Documents</SPAN><br>Autores = Alda Lopes Gancarski, Bruno Defude, Daniela da Cruz, Flavio Xavier Ferreira, Pedro Rangel Henriques</P>
<P>Key = BHVU09<br>Title = <SPAN>Instrumentaciones de Programas Escritos en C para Interrelacionar las Vistas Comportamental y Operacional de los Sistemas de Software</SPAN><br>Autores = Maria Joao Varanda Pereira, Mario Beron, Pedro Rangel Henriques, Roberto Uzal</P>
<P>Key = CH09d<br>Title = <SPAN>Assessing Databases in .Net: comparing approaches</SPAN><br>Autores = Daniela da Cruz, Pedro Rangel Henriques</P>
<P>Key = CH2010a<br>Title = <SPAN>Exploring, Visualizing and Slicing the Soul of XML Documents</SPAN><br>Autores = Daniela da Cruz, Pedro Rangel Henriques</P>
<H3>mastersthesis</H3>
<P>Key = teseambs<br>Title = <SPAN>Parallel Corpora word alignment and applications</SPAN><br>Autores = Alberto Manuel Brandao Simoes</P>
<H3>misc</H3>
<P>Key = cruz09<br>Title = <SPAN>GraAL - A Grammar Analyzer</SPAN><br>Autores = Daniela da Cruz, Nuno Oliveira, Pedro Rangel Henriques</P>
<H3>phdthesis</H3>
<P>Key = tesejj<br>Title = <SPAN>Dicionários dinâmicos multi-fonte</SPAN><br>Autores = Jose Joao Dias de Almeida</P>
<H3>techreport</H3>
<P>Key = tlc89<br>Title = <SPAN>Teoria das Linguagens</SPAN><br>Autores = J.B. Barros, Jose Joao Dias de Almeida</P>
<P>Key = estruturasdedados90<br>Title = <SPAN>Estruturas de Dados</SPAN><br>Autores = J.B. Barros, Jose Joao Dias de Almeida</P>
<P>Key = Camila<br>Title = <SPAN><SPAN STYLE="font-variant:small-caps">Camila</SPAN> - A Platform for Software Mathematical Development</SPAN><br>Autores = projecto Camila</P>
<P>Key = Natura<br>Title = <SPAN>Natura - Natural language processing</SPAN><br>Autores = Jose Joao Dias de Almeida</P>
<P>Key = jspell1<br>Title = <SPAN>Manual de Utilizador do JSpell</SPAN><br>Autores = Jose Joao Dias de Almeida, Ulisses Pinto</P>
<P>Key = jj95<br>Title = <SPAN>NLlex -- a tool to generate lexical analysers for natural language</SPAN><br>Autores = Jose Joao Dias de Almeida</P>
<P>Key = Barbosa95<br>Title = <SPAN>System Prototyping in <SPAN STYLE="font-variant:small-caps">Camila</SPAN></SPAN><br>Autores = Jose Joao Dias de Almeida, L.S. Barbosa</P>
<P>Key = Barbosa95a<br>Title = <SPAN><SPAN STYLE="font-variant:small-caps">Camila</SPAN>: A reference Manual</SPAN><br>Autores = Jose Joao Dias de Almeida, L.S. Barbosa</P>
<P>Key = BA97a<br>Title = <SPAN>Systems Prototyping in <SPAN STYLE="font-variant:small-caps">Camila</SPAN></SPAN><br>Autores = Jose Joao Dias de Almeida, L.S. Barbosa</P>
<P>Key = Barbosa95b<br>Title = <SPAN>Growing Up With <SPAN STYLE="font-variant:small-caps">Camila</SPAN></SPAN><br>Autores = Jose Joao Dias de Almeida, L.S. Barbosa</P>
<P>Key = Almeida96c<br>Title = <SPAN>From BiBTeX to HTML semantic nets</SPAN><br>Autores = Jose Carlos Ramalho, Jose Joao Dias de Almeida</P><H2>Author Index</H2>
<H3>A</H3>
<P>Afonso, S., linguateca</P>
<P>Aires, R., linguateca</P>
<P>Almeida, J. J. D., sepln2004, jspell1, xata07:xmltmx, Barbosa95, epia-music-2007, tlc89, xata:xmldt, elpub2003, APL2k2.Parguess, sepln06, freq2002, Almeida96a, Barbosa95b, xata06:xmlauto, eamt06, Gis99, jj95, RSea99, Barbosa2000, Almeida94b, APL2k2.Synthesis, tesejj, xata04:mtd, graminteractivas1990, SGML97, elpub06-blind, Ramalho96, elpub06-t2o, Ramalho98, Natura, Almeida94c, BA97a, jspell2002, Barbosa95a, Almeida98, cp3a:terminum2003, AH97, RRAH99, mp2001, xata06:navegante, xata:museudapessoa, RARH98, ABBN98, RAH98, xata04:tx, MP07, Reis98, alfarrabio2001, linguateca, dag2002, Almeida95a, avalon:jspell, Ramalho95, jj96, ABNO97b, Ulisses96, xmldt99, jj2001x, museums98, RPA99, sepln2003, xata05:fs, xata05:tdt, ABNO97a, avalon:avalinha, harem:rena, speaker:sepln2001, elpub2002, estruturasdedados90, Almeida96c, parguess2002, Almeida96b, epia-bio-2007, lrec06</P>
<P>Arnold, G., ALHF02</P>
<P>Augustin, I., LGFSSAH08</P>
<P>Azevedo, R. P., LPRH07-TM, LARH09, LPRH07</P>
<H3>B</H3>
<P>Barbosa, L. S., ABBN98, Barbosa95, ABNO97a, Barbosa95b, BA97a, Barbosa95a, Barbosa2000, ABNO97b</P>
<P>Barreiro, A., linguateca</P>
<P>Barroca, L., BH98</P>
<P>Barros, J. B., ABBN98, tlc89, estruturasdedados90, Almeida96b, Barbosa2000</P>
<P>Beron, M., BCVHU08, BHVU08, BHVU07a, CBHP09, BHVU06b, BHVU06a, BHVU07d, BHVUM06, CFPBH07d, BHVU09, CHLB07a, BUHV08, BHV06, BHVU07b, BHVU07c</P>
<P>Bick, E., linguateca, xata05:fs</P>
<H3>C</H3>
<P>Cabral, L., linguateca</P>
<P>Camila, , Camila</P>
<P>Cardoso, N., linguateca</P>
<P>Carvalho, A., elpub06-blind</P>
<P>Castro, J. A., cp3a:terminum2003, APL2k2.Parguess, parguess2002</P>
<P>Chaves, M., linguateca</P>
<P>Costa, L., linguateca</P>
<P>Cramer, B., OPHCC09, OPHCC2010</P>
<P>Crepinsek, M., oliveira09b, KOMPCCH2010</P>
<P>Cruz, D., kosar09, CHV07, oliveira09b, OPCH09a, FCHV08, FPCH08jb, BCVHU08, CHP08b, PMCH08j, OPHCC09, FPCH08d, CHV08ja, CHP08a, PMCH08f, oliveira09c, CPH08c, CH07a, CHP09a, CH07h, FCHGD09b, OPHC09a, CH09d, RMHCV06, OPHCC2010, PMCH08e, CH2010a, CHP08i, CH07d, KOMPCCH2010, cruz09, CLH07c, CBHP09, MKCHCPO09, RMHVC06, OHCP09, FCHGD09a, CPH07f, CH07g, CFPBH07d</P>
<P>Cunha, E., CHLB07a</P>
<H3>D</H3>
<P>Defude, B., FCHGD09a, FCHGD09b</P>
<P>Doucet, A., GDH06</P>
<H3>F</H3>
<P>Faria, J. L., museums98</P>
<P>Fernandes, A. R., elpub06-blind</P>
<P>Ferreira, E., FPCH08jb, FPCH08d, epia-bio-2007</P>
<P>Ferreira, F. X., FCHGD09b, GFH08, FGH08, FCHGD09a, FH08</P>
<P>Fonseca, J., ALHF02</P>
<P>Fonseca, R., FCHV08, MP07, CFPBH07d</P>
<P>Frankenberg-Garcia, A. F., linguateca</P>
<P>Freitas, L. O., LGFSSAH08</P>
<H3>G</H3>
<P>Gancarski, A. L., GH07a, FCHGD09b, GDH06, FGH08, GFH08, FCHGD09a, GH07b</P>
<P>Gassen, J. B., LRHGT08, LGFSSAH08</P>
<P>Gray, J., HVMLGW05</P>
<P>Guinovart, X. G., sepln2004, xata04:mtd</P>
<H3>H</H3>
<P>Henriques, M. R., RSea99, museums98, Gis99</P>
<P>Henriques, P. R., BHVU08, VH02, LRHGT08, OPCH09a, GRH04, FCHV08, BCVHU08, CHP08b, OPHCC09, FPCH08d, ORH06, CHV08ja, BUHV08, CHP08a, oliveira09c, OVH05, CH07a, CHP09a, ORH09a, alfarrabio2001, OPHCC2010, RMHV06, dag2002, museums98, LGFSSAH08, CBHP09, GRH06, LARH09, RH02, GDH06, FPCH08jb, MSH05, graminteractivas1990, BHVU09, CHLB07a, RH98a, RARH98, AH97, BHVU07d, GH07b, CPH08c, RAH98, RRH02, RMHCV06, PMCH08e, BHVU07b, CHP08i, CLH07c, BHVU06a, BH98, CFPBH07d, kosar09, BHVU07a, CHV07, oliveira09b, BHVUM06, FGH08, Gis99, RSea99, BHV06, SGML97, Ramalho96, LPRH07, BHVU06b, RRAH99, mp2001, VH03, CH07h, OPHC09a, GRH05a, Ramalho95, CH07d, JGRH03, MKCHCPO09, OHCP09, FCHGD09a, CPH07f, CH07g, JGRH04, LPRH07-TM, PMCH08j, HVMLGW05, GFH08, Ramalho98, PMCH08f, FH08, GH07a, CH09d, VH01, HKMVZ03, CH2010a, BHVU07c, LPH09a, KOMPCCH2010, cruz09, ALHF02, LMMVRH08, RMHVC06, OHV06, FCHGD09b, KMHVZ04</P>
<H3>J</H3>
<P>Jacinto, M., JGRH04, JGRH03</P>
<H3>K</H3>
<P>Kosar, T., kosar09, MKCHCPO09, oliveira09b, HKMVZ03, KMHVZ04, KOMPCCH2010</P>
<H3>L</H3>
<P>Lenic, M., HVMLGW05, VH02</P>
<P>Librelotto, G. R., JGRH04, JGRH03, LPRH07-TM, LGFSSAH08, ALHF02, LRHGT08, GRH06, LMMVRH08, LARH09, GRH05a, GRH04, LPRH07, LPH09a</P>
<P>Lopes, S. C., CHLB07a, CLH07c</P>
<P>Lourenco, A., epia-bio-2007, epia-music-2007</P>
<H3>M</H3>
<P>Machado, H., LMMVRH08</P>
<P>Maia, B., linguateca</P>
<P>Martins, B., cp3a:terminum2003, cp3a:kvec2003</P>
<P>Martins, F. M., graminteractivas1990</P>
<P>Martins, M., LMMVRH08</P>
<P>Mendes, G., MSH05</P>
<P>Mernik, M., kosar09, PMCH08j, RMHV06, MKCHCPO09, HVMLGW05, VH02, oliveira09b, RMHVC06, RMHCV06, HKMVZ03, PMCH08f, KMHVZ04, PMCH08e, KOMPCCH2010</P>
<P>Montejano, G., BHVUM06</P>
<P>Moreira, S., mp2001</P>
<P>Mota, C., linguateca</P>
<H3>N</H3>
<P>Neves, F. L., ABNO97a, ABNO97b</P>
<P>Neves, L. F., ABBN98</P>
<H3>O</H3>
<P>Oliveira, D., linguateca</P>
<P>Oliveira, E., OVH05, OHV06</P>
<P>Oliveira, J. N., ABNO97a, ABNO97b</P>
<P>Oliveira, N., kosar09, cruz09, MKCHCPO09, oliveira09b, OPHC09a, OPHCC09, OPCH09a, OHCP09, OPHCC2010, oliveira09c, KOMPCCH2010</P>
<P>Oliveira, P., ORH06</P>
<P>Oliveria, P. J., ORH09a</P>
<H3>P</H3>
<P>Paulo, R., FPCH08jb, FPCH08d</P>
<P>Pedroso, T., RPA99</P>
<P>Pereira, M. J. V., kosar09, BHVU08, BHVU07a, VH02, CHV07, oliveira09b, BHVUM06, OPCH09a, FCHV08, BHV06, BCVHU08, CHP08b, PMCH08j, HVMLGW05, CPH07f, OPHCC09, BHVU09, CHV08ja, BUHV08, CHP08a, PMCH08f, BHVU06b, oliveira09c, BHVU07d, OVH05, VH03, OPHC09a, VH01, RMHCV06, OPHCC2010, RMHV06, HKMVZ03, BHVU07b, CHP08i, PMCH08e, BHVU07c, KOMPCCH2010, CBHP09, MKCHCPO09, BHVU06a, RMHVC06, OHCP09, OHV06, KMHVZ04, CFPBH07d</P>
<P>Pereira, R. T., LPH09a</P>
<P>Pinto, A., linguateca</P>
<P>Pinto, J. S., CHP09a, CPH08c</P>
<P>Pinto, U., Ulisses96, jspell1, Almeida94c</P>
<H3>R</H3>
<P>Ramalho, J. C., LRHGT08, GRH04, JGRH04, LPRH07-TM, SGML97, Ramalho96, Ramalho98, LPRH07, RH98a, RARH98, RRAH99, RAH98, GRH05a, Ramalho95, xmldt99, JGRH03, museums98, LMMVRH08, GRH06, LARH09, Almeida96c, RH02</P>
<P>Ramos, C., RRH02</P>
<P>Ranchhod, E., linguateca</P>
<P>Rebernak, D., RMHVC06, RMHCV06, RMHV06</P>
<P>Reis, R., Reis98</P>
<P>Rocha, I., epia-bio-2007</P>
<P>Rocha, J. G., museums98, RPA99, SGML97, alfarrabio2001, Gis99, RSea99, RARH98, RRAH99, mp2001</P>
<P>Rocha, M., epia-bio-2007</P>
<P>Rocha, P. A., linguateca, freq2002</P>
<P>Rodrigues, M. F., ORH09a, RRH02, ORH06</P>
<H3>S</H3>
<P>Santos, D., linguateca</P>
<P>Sarmento, L., linguateca</P>
<P>Silva, A., RSea99, Gis99</P>
<P>Silva, F. L., LGFSSAH08</P>
<P>Silva, N. A., MSH05</P>
<P>Silva, P., cp3a:terminum2003</P>
<P>Silva, R., linguateca</P>
<P>Silveira, M. C., LGFSSAH08</P>
<P>Simoes, A. M. B., sepln2004, xata07:xmltmx, teseambs, epia-music-2007, xata:xmldt, elpub2003, sepln06, APL2k2.Parguess, freq2002, xata06:xmlauto, eamt06, APL2k2.Synthesis, xmldt2, xata04:mtd, elpub06-blind, elpub06-t2o, cp3a:terminum2003, jspell2002, mp2001, xata06:navegante, xata:museudapessoa, xata04:tx, MP07, cp3a:natools2003, alfarrabio2001, linguateca, dag2002, avalon:jspell, xata05:tdt, sepln2003, xata05:fs, avalon:avalinha, speaker:sepln2001, elpub2002, parguess2002, epia-bio-2007, lrec06</P>
<H3>T</H3>
<P>Turchetti, R. C., LRHGT08</P>
<H3>U</H3>
<P>Uzal, R., BCVHU08, BHVU08, BHVU07a, BHVU06b, BHVU06a, BHVU07d, BHVUM06, BHVU09, BUHV08, BHVU07b, BHVU07c</P>
<H3>V</H3>
<P>Vilela, R., linguateca, xata05:fs</P>
<P>Vizzotto, J., LMMVRH08</P>
<H3>W</H3>
<P>Wu, H., HVMLGW05</P>
<H3>Z</H3>
<P>Zumer, V., KMHVZ04, HKMVZ03</P></BODY>
</HTML>
```